; SWEET32 Include file



sw32_regb = $69

R0	= $00 + sw32_regb
R1	= $01 + sw32_regb
R2	= $02 + sw32_regb
R3	= $03 + sw32_regb
R4	= $04 + sw32_regb
R5	= $05 + sw32_regb
R6	= $06 + sw32_regb
R7	= $07 + sw32_regb
R8	= $08 + sw32_regb
R9	= $09 + sw32_regb
R10	= $0A + sw32_regb
R11	= $0B + sw32_regb
R12	= $0C + sw32_regb
R13	= $0D + sw32_regb
R14	= $0E + sw32_regb
R15	= $0F + sw32_regb
SR  = R0 ; Used for the SET/CLR Instructions

Z	= %00000010
C	= %00000100
N	= %00001000
F4	= %00010000
F5	= %00100000
F6	= %01000000
F7	= %10000000


; <---------------------------------------------------------------------------------------------------------->
; Branch on Clear (ie branch if bit "v" of SR is 0)
; <---------------------------------------------------------------------------------------------------------->

; Branch on "Not Zero"
.macro BNZ addr
	.byte $20
	.byte <((.LOWORD(addr) - (* + 1)) >> 1)
.endmacro

; Branch on "Not Carry"
.macro BNC addr
	.byte $40
	.byte <((.LOWORD(addr) - (* + 1)) >> 1)
.endmacro

; Branch on "Not Negative"
.macro BNN addr
	.byte $60
	.byte <((.LOWORD(addr) - (* + 1)) >> 1)
.endmacro

; Branch on "Not F4"
.macro BNF4 addr
	.byte $80
	.byte <((.LOWORD(addr) - (* + 1)) >> 1)
.endmacro

; Branch on "Not F5"
.macro BNF5 addr
	.byte $A0
	.byte <((.LOWORD(addr) - (* + 1)) >> 1)
.endmacro

; Branch on "Not F6"
.macro BNF6 addr
	.byte $C0
	.byte <((.LOWORD(addr) - (* + 1)) >> 1)
.endmacro

; Branch on "Not F7"
.macro BNF7 addr
	.byte $E0
	.byte <((.LOWORD(addr) - (* + 1)) >> 1)
.endmacro

; <---------------------------------------------------------------------------------------------------------->
; Branch on Set (ie branch if bit "v" of SR is 1)
; <---------------------------------------------------------------------------------------------------------->

; Branch on "Zero"
.macro BZ addr
	.byte $30
	.byte <((.LOWORD(addr) - (* + 1)) >> 1)
.endmacro

; Branch on "Carry"
.macro BC addr
	.byte $50
	.byte <((.LOWORD(addr) - (* + 1)) >> 1)
.endmacro

; Branch on "Negative"
.macro BN addr
	.byte $70
	.byte <((.LOWORD(addr) - (* + 1)) >> 1)
.endmacro

; Branch on "F4"
.macro BF4 addr
	.byte $90
	.byte <((.LOWORD(addr) - (* + 1)) >> 1)
.endmacro

; Branch on "F5"
.macro BF5 addr
	.byte $B0
	.byte <((.LOWORD(addr) - (* + 1)) >> 1)
.endmacro

; Branch on "F6"
.macro BF6 addr
	.byte $D0
	.byte <((.LOWORD(addr) - (* + 1)) >> 1)
.endmacro

; Branch on "F7"
.macro BF7 addr
	.byte $F0
	.byte <((.LOWORD(addr) - (* + 1)) >> 1)
.endmacro

; <---------------------------------------------------------------------------------------------------------->
; Jump and Link (PC -> Re; Ra -> PC)
; <---------------------------------------------------------------------------------------------------------->

.macro JAL Re, Ra
	.byte (($F0 & <((Ra - sw32_regb) << 4)) | $01)
	.byte ($0F & <(Re - sw32_regb))
.endmacro

; <---------------------------------------------------------------------------------------------------------->
; Add (Re = Ra + Rb)
; <---------------------------------------------------------------------------------------------------------->

.macro ADR Re, Ra, Rb
	.byte (($F0 & <((Ra - sw32_regb) << 4)) | $02)
	.byte (($F0 & (<(Rb - sw32_regb) << 4)) | ($0F & <(Re - sw32_regb)))
.endmacro

; <---------------------------------------------------------------------------------------------------------->
; Subtract (Re = Ra - Rb)
; <---------------------------------------------------------------------------------------------------------->

.macro SBR Re, Ra, Rb
	.byte (($F0 & <((Ra - sw32_regb) << 4)) | $03)
	.byte (($F0 & (<(Rb - sw32_regb) << 4)) | ($0F & <(Re - sw32_regb)))
.endmacro

; <---------------------------------------------------------------------------------------------------------->
; Logic AND (Re = Ra & Rb)
; <---------------------------------------------------------------------------------------------------------->

.macro ANR Re, Ra, Rb
	.byte (($F0 & <((Ra - sw32_regb) << 4)) | $04)
	.byte (($F0 & (<(Rb - sw32_regb) << 4)) | ($0F & <(Re - sw32_regb)))
.endmacro

; <---------------------------------------------------------------------------------------------------------->
; Logic OR (Re = Ra | Rb)
; <---------------------------------------------------------------------------------------------------------->

.macro ORR Re, Ra, Rb
	.byte (($F0 & <((Ra - sw32_regb) << 4)) | $05)
	.byte (($F0 & (<(Rb - sw32_regb) << 4)) | ($0F & <(Re - sw32_regb)))
.endmacro

; <---------------------------------------------------------------------------------------------------------->
; Logic XOR (Re = Ra ^ Rb)
; <---------------------------------------------------------------------------------------------------------->

.macro XOR Re, Ra, Rb
	.byte (($F0 & <((Ra - sw32_regb) << 4)) | $06)
	.byte (($F0 & (<(Rb - sw32_regb) << 4)) | ($0F & <(Re - sw32_regb)))
.endmacro

; <---------------------------------------------------------------------------------------------------------->
; Logic Shift Left (Re = Ra << 1) (0 -> LSB; MSB -> Carry)
; <---------------------------------------------------------------------------------------------------------->

.macro SFL Re, Ra
	.byte (($F0 & <((Ra - sw32_regb) << 4)) | $07)
	.byte ($0F & <(Re - sw32_regb))
.endmacro

; <---------------------------------------------------------------------------------------------------------->
; Logic Shift Right (Re = Ra >> 1) (0 -> MSB; LSB -> Carry)
; <---------------------------------------------------------------------------------------------------------->

.macro SFR Re, Ra
	.byte (($F0 & <((Ra - sw32_regb) << 4)) | $08)
	.byte ($0F & <(Re - sw32_regb))
.endmacro

; <---------------------------------------------------------------------------------------------------------->
; Rotate Left (Re = Ra << 1) (Carry -> LSB; MSB -> Carry)
; <---------------------------------------------------------------------------------------------------------->

.macro RLR Re, Ra
	.byte (($F0 & <((Ra - sw32_regb) << 4)) | $09)
	.byte ($0F & <(Re - sw32_regb))
.endmacro

; <---------------------------------------------------------------------------------------------------------->
; Rotate Right (Re = Ra >> 1) (Carry -> MSB; LSB -> Carry)
; <---------------------------------------------------------------------------------------------------------->

.macro RRR Re, Ra
	.byte (($F0 & <((Ra - sw32_regb) << 4)) | $0A)
	.byte ($0F & <(Re - sw32_regb))
.endmacro

; <---------------------------------------------------------------------------------------------------------->
; Add Immediate (Rx = Rx + imm)
; <---------------------------------------------------------------------------------------------------------->

.macro ADI Rx, imm
	.byte (($F0 & <((Rx - sw32_regb) << 4)) | $0B)
	.byte <(imm)
.endmacro

; <---------------------------------------------------------------------------------------------------------->
; Load Byte (Re = Memory[Ra])
; <---------------------------------------------------------------------------------------------------------->

.macro LB Re, Ra
	.byte (($F0 & <((Ra - sw32_regb) << 4)) | $0C)
	.byte ($F0 & <((Re - sw32_regb) << 4))
.endmacro

; <---------------------------------------------------------------------------------------------------------->
; Load Byte (Unsigned) (Re = Memory[Ra])
; <---------------------------------------------------------------------------------------------------------->

.macro LBU Re, Ra
	.byte (($F0 & <((Ra - sw32_regb) << 4)) | $0C)
	.byte (($F0 & <((Re - sw32_regb) << 4)) | $01)
.endmacro

; <---------------------------------------------------------------------------------------------------------->
; Load Word (Re = Memory[Ra])
; <---------------------------------------------------------------------------------------------------------->

.macro LW Re, Ra
	.byte (($F0 & <((Ra - sw32_regb) << 4)) | $0C)
	.byte (($F0 & <((Re - sw32_regb) << 4)) | $02)
.endmacro

; <---------------------------------------------------------------------------------------------------------->
; Load Word (Unsigned) (Re = Memory[Ra])
; <---------------------------------------------------------------------------------------------------------->

.macro LWU Re, Ra
	.byte (($F0 & <((Ra - sw32_regb) << 4)) | $0C)
	.byte (($F0 & <((Re - sw32_regb) << 4)) | $03)
.endmacro

; <---------------------------------------------------------------------------------------------------------->
; Load Long (Re = Memory[Ra])
; <---------------------------------------------------------------------------------------------------------->

.macro LL Re, Ra
	.byte (($F0 & <((Ra - sw32_regb) << 4)) | $0C)
	.byte (($F0 & <((Re - sw32_regb) << 4)) | $04)
.endmacro

; <---------------------------------------------------------------------------------------------------------->
; Store Byte (Memory[Ra] = Rb)
; <---------------------------------------------------------------------------------------------------------->

.macro SB Ra, Rb
	.byte (($F0 & <((Ra - sw32_regb) << 4)) | $0C)
	.byte (($F0 & <((Rb - sw32_regb) << 4)) | $08)
.endmacro

; <---------------------------------------------------------------------------------------------------------->
; Store Word (Memory[Ra] = Rb)
; <---------------------------------------------------------------------------------------------------------->

.macro SW Ra, Rb
	.byte (($F0 & <((Ra - sw32_regb) << 4)) | $0C)
	.byte (($F0 & <((Rb - sw32_regb) << 4)) | $09)
.endmacro

; <---------------------------------------------------------------------------------------------------------->
; Store Long (Memory[Ra] = Rb)
; <---------------------------------------------------------------------------------------------------------->

.macro SL Ra, Rb
	.byte (($F0 & <((Ra - sw32_regb) << 4)) | $0C)
	.byte (($F0 & <((Rb - sw32_regb) << 4)) | $0A)
.endmacro

; <---------------------------------------------------------------------------------------------------------->
; Set bit (Rx = Rx | bitmask[imm])
; <---------------------------------------------------------------------------------------------------------->

.macro SET Rx, imm
	.byte (($F0 & <((Rx - sw32_regb) << 4)) | $0D)
	.byte <(imm)
.endmacro

; <---------------------------------------------------------------------------------------------------------->
; Clear bit (Rx = Rx | bitmask[imm])
; <---------------------------------------------------------------------------------------------------------->

.macro CLR Rx, imm
	.byte (($F0 & <((Rx - sw32_regb) << 4)) | $0E)
	.byte <(imm)
.endmacro

; <---------------------------------------------------------------------------------------------------------->
; Load Word Immediate (Re = imm)
; <---------------------------------------------------------------------------------------------------------->

.macro LWI Re, imm
	.byte (($F0 & <((Re - sw32_regb) << 4)) | $0F)
	.byte $00
	.word .LOWORD(imm)
.endmacro

; <---------------------------------------------------------------------------------------------------------->
; Load Word (Unsigned) Immediate (Re = imm)
; <---------------------------------------------------------------------------------------------------------->

.macro LWIU Re, imm
	.byte (($F0 & <((Re - sw32_regb) << 4)) | $0F)
	.byte $01
	.word .LOWORD(imm)
.endmacro

; <---------------------------------------------------------------------------------------------------------->
; Load Long Immediate (Re = imm)
; <---------------------------------------------------------------------------------------------------------->

.macro LLI Re, imm
	.byte (($F0 & <((Re - sw32_regb) << 4)) | $0F)
	.byte $02
	.word .LOWORD(imm)
	.word .HIWORD(imm)
.endmacro

; <---------------------------------------------------------------------------------------------------------->
; Return to 65816 Mode
; <---------------------------------------------------------------------------------------------------------->

.macro EXIT
	.word $FFFF
.endmacro







